define HOST="127.0.0.1"
define PORT=8089
define OK=200
define BAD_REQ=400
define NOT_FOUND=404


component DaisyAdapter(status_OK) in, status, work_result, work_status -> work_data, out, status {
  """
  Allow daisy-chaining of data/status along a processing flow.

  Conceptually, the flow looks like the following picture:

                +-----------+          +-----------+          +-----------+
                |   actor   |          |   actor   |          |   actor   |
                |           |          |           |          |           |
                |     r  s  |          |     r  s  |          |     r  s  |
                |     e  t  |          |     e  t  |          |     e  t  |
                |  d  s  a  |          |  d  s  a  |          |  d  s  a  |
                |  a  u  t  |          |  a  u  t  |          |  a  u  t  |
                |  t  l  u  |          |  t  l  u  |          |  t  l  u  |
                |  a  t  s  |          |  a  t  s  |          |  a  t  s  |
                +-----------+          +-----------+          +-----------+
                   ^  |  |                ^  |  |                ^  |  |
                   |  v  v                |  v  v                |  v  v
         data   +--+--+--+--+   data   +--+--+--+--+   data   +--+--+--+--+   data
  ... --------->|           |--------->|           |--------->|           |---------> ...
        status  |   daisy   |  status  |   daisy   |  status  |   daisy   |  status
  ... --------->|           |--------->|           |--------->|           |---------> ...
                +-----------+          +-----------+          +-----------+

  Data propagates down the chain and is processed by the actors, in order, as long as each actor
  reports its status as OK (according to the argument provided to DaisyAdapter). If an actor reports
  its status as not OK, the error status and the corresponding data is simply propagated down the
  flow, without further processing.
  """

  status_check : std.Compare(op="=")
  route_input : flow.Select()
  route_status : flow.Switch()
  join_output : flow.Collect()

  # Is incoming status OK?
  status_OK > status_check.a
  .status > status_check.b
  # Route input and status based on the outcome of checking input status
  status_check.result > route_status.switch, route_input.select

  .status > route_status.a
  .work_status > route_status.b
  route_status.b > voidport
  route_status.a > .status

  .in > route_input.data
  route_input.case_true > .work_data
  route_input.case_false > join_output.token
  .work_result > join_output.token
  join_output.token > .out
}

component HTTPGETRequestCheck() request -> path, status {
  """
  Check if request is valid HTTP GET request.

  Input:
	  request: an HTTP request, possibly malformed
  Outputs:
    path: the requested resource path, or the full request on error
    status: the request status, either OK (200) or Bad Request (400)
  """
  match_request_method : text.RegexMatch(regex="(GET) \S+ HTTP/\d\.\d")
  match_request_path : text.RegexMatch(regex="[A-Z]+ (\S+) HTTP/\d\.\d")
  join_output : flow.Collect()
  join_status : flow.Collect()

  .request > match_request_method.text
  .request > match_request_path.text

  match_request_path.match > join_output.token
  match_request_path.no_match > join_output.token
  join_output.token > .path
  // Successful path
  match_request_method.match > /OK/ join_status.token
  // Error path
  match_request_method.no_match > /BAD_REQ/ join_status.token
  // Status
  join_status.token > .status
}

# Alternative implementation of HTTPGETRequestCheck, not used
component HTTPGETRequestCheck_ALT() request -> path, status {
  """
  Check if request is valid HTTP GET request.

  Input:
	  request: an HTTP request, possibly malformed
  Outputs:
    path: the requested resource path, or the full request on error
    status: the request status, either OK (200) or Bad Request (400)
  """
  split_request : text.Split(delim=" ")
  request_method : json.GetValue()
  request_path : json.GetValue()
  check_method : std.Compare(op="=")
  status : flow.Deselect()
  route_path : flow.Switch()

  .request > split_request.text
  split_request.lines > request_method.container, request_path.container
  0 > request_method.key
  1 > request_path.key

  request_method.value > check_method.a
  "GET" > check_method.b
  check_method.result > status.select, route_path.switch

  OK > status.case_true
  BAD_REQ > status.case_false
  status.data > .status

  request_path.value > route_path.b
  .request > route_path.a
  route_path.b > voidport
  route_path.a > .path
}


component HTTPResourceLocator(base_path) rel_path -> abs_path, status {
  """
  Locate a resource by appending rel_path to base_path.
  If the resulting path is outside of base_path,
  or if the resource doesn't exist an error is generated.

  Input:
    rel_path : Path for resource relative to base_path
  Outputs:
    abs_path : Absolute path to resource.
    status : An integer status code (200) 'OK' or (404) 'Not found'
  """

  status : flow.Deselect()
  abs_path : path.Append(inside_base=true)

  base_path > abs_path.base
  .rel_path > abs_path.append
  # Partially successful path
  abs_path.path > .abs_path
  # Update status based on error
  # false => OK
  # true => FILE NOT FOUND
  abs_path.error > status.select
  OK > status.case_false
  NOT_FOUND > status.case_true
  status.data > .status
}


component HTTPFileReader() filename -> resource, status {
  """
  Concatenate lines into a chunk of text (the requested resource)

  Input:
    filename : the resource to read
  Outputs:
    resource : contents of resource file
    status : OK (200) or File not found (404)
  """
  read_html : io.FileReader()
  concat : text.LineJoin()
  exception_handler : exception.ExceptionHandler()
  is_eos : std.Compare(op="=")
  status_mapper : flow.Deselect()


  .filename > read_html.filename
  read_html.out > exception_handler.token
  exception_handler.token > concat.line
  concat.text > .resource
  exception_handler.status > is_eos.a
  "End of stream" > is_eos.b
  is_eos.result > status_mapper.select
  OK > status_mapper.case_true
  NOT_FOUND > status_mapper.case_false
  status_mapper.data > .status
}


tcp_server : net.TCPServer(delimiter="\r\n\r\n")
daisy_GET : DaisyAdapter(status_OK=OK)
daisy_path : DaisyAdapter(status_OK=OK)
daisy_resource : DaisyAdapter(status_OK=OK)
check_GET : HTTPGETRequestCheck()
resource_path : HTTPResourceLocator(base_path="html")
resource_reader : HTTPFileReader()
resp: http.HTTPResponseGenerator()

HOST > tcp_server.host
PORT > tcp_server.port
# This line is a surprising consequence of the dataflow paradigm
tcp_server.handle > tcp_server.handle

# Bootstrap status (OK)
tcp_server.token > /OK/ daisy_GET.status
# Request
tcp_server.token > daisy_GET.in

daisy_GET.work_data > check_GET.request
check_GET.path > daisy_GET.work_result
check_GET.status > daisy_GET.work_status

daisy_GET.status > daisy_path.status
daisy_GET.out > daisy_path.in

daisy_path.work_data > resource_path.rel_path
resource_path.abs_path > daisy_path.work_result
resource_path.status > daisy_path.work_status

daisy_path.status > daisy_resource.status
daisy_path.out > daisy_resource.in

daisy_resource.work_data > resource_reader.filename
resource_reader.resource > daisy_resource.work_result
resource_reader.status > daisy_resource.work_status

daisy_resource.status > resp.status
daisy_resource.out > resp.body

resp.out > tcp_server.token

# Logging
# Tip: To help with debugging, attach a Print actor
#      to any output port to log the data flow, e.g.
# snk: io.Print()
# tcp_server.token > snk.token

