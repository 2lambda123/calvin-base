"""
Security Discovery Exchange.
The purpose of this module is to create an exchange of credentials
from a new Client joining a domain to a Certificate Authority
authorizing the new Node to join the domain.

Transmit a Certificate Signature Request from a new node over multicast SSDP
to a Certificate Authority Cettificate Authority can sign request or not
depending on a configuration over unicast.
Node         Certificate Authority
 |------CSR,CA-FP---->|
 |                    | Signature()
 |<---Certificate,CA--|
 |                    |

The certificate discovery services are divided in two sections.
One for new clients and one for certificate authority functions.
By collecting and recording states for a Node and a Ca it is possible to
leave a Security Discovery Exchange at any time and continue later if a
temporary error has occured.
Errors generate exceptions and the exception handler manages the error state
unless successfull.

Use sphinx.ext.autodoc to extract comments on enums.
"""

import os

import OpenSSL

from calvin.utilities.utils import enum
from calvin.utilities import certificate
from calvin.utilities import calvinconfig
from calvin.runtime.south.plugins.storage.\
        twistedimpl.securedht import service_discovery_ssdp

STATE = enum("NEW",  # Object is initiated but not loaded or started.
             "CONFIGURED",  # An acceptable configuration is loaded.
             "LISTENING",  # Listen for request or response.
             "TRANSMIT",  # Transmit a request or response.
             "SATISFIED",  # Required security discoveries established.
             "CSR_GENERATED",  # CSR has been generated.
             "CSR_REQUESTED",  # CSR has been requested.
             "CERTIFICATE_RECEIVED",  # Certificate has been received.
             "CERTIFICATE_VALID",  # Certificate validly signed by CA.
             "CA_ACCEPTED_CONFIGURATION",  # CAcert meets config requirements.
             "CERTIFICATE_ACCEPTED_CONFIGURATION",  # Certificate meets req.
             "CA_STORED",  # CA cert stored.
             "CERTIFICATE_STORED",  # Certificate stored.
             "CA_GENERATED",  # CA cert generated.
             "CSR_RECEIVED",  # CSR has been received.
             "CSR_ACCEPTED",  # CSR meets config requirements.
             "CSR_SIGNED",  # CSR have been signed by CA.
             "CSR_ALREDY_SIGNED",  # The requested CSR already signed.
             "CERTIFICATE_GENERATED")  # Certificate generated by CA

TYPE_ECC = 408  # Internal type name for ECC keys in version3 of PKCS#10.


# Generic helper functions.
def load_cert(cert_file):
    """
    Load the `cert_file` (can be CSR or CERT) to a
    OpenSSL X509 object and return it.

    Raise IOError if the file is missing.
    Raise OpenSSL.crypto.Error on OpenSSL errors.
    """
    with open(cert_file, 'r') as ca_fd:
        cadata = ca_fd.read()
    cert_part = cadata.split(certificate.BEGIN_LINE)[1]
    certstr = "{}{}".format(certificate.BEGIN_LINE, cert_part)
    load_certificate = OpenSSL.crypto.load_certificate
    try:
        cert = load_certificate(OpenSSL.crypto.FILETYPE_PEM, certstr)
    except:
        load_certificate = OpenSSL.crypto.load_certificate_request
        try:
            cert = load_certificate(OpenSSL.crypto.FILETYPE_PEM, certstr)
        except:
            raise
    return cert


def verify_cert_with_policy(cert):
    """
    Confirm that a `cacert` is allowed in security configuration policy.
    Comparing with NIST:
    http://csrc.nist.gov/publications/PubsFIPS.html#fips186-3
    """
    certx509 = load_cert(cert)
    pubkey = certx509.get_pubkey()
    if pubkey.type() is TYPE_ECC and pubkey.bits() < 256:
        raise CertificateDeniedConfiguration("Too small ECC key in cert.")
    if pubkey.type() is OpenSSL.crypto.TYPE_RSA and pubkey.bits < 2048:
        raise CertificateDeniedConfiguration("Too small RSA key in cert.")
    if pubkey.type() is OpenSSL.crypto.TYPE_DSA and pubkey.bits < 2048:
        raise CertificateDeniedConfiguration("Too small DSA key in cert.")


# Exceptions
class ConfigurationMalformed(Exception):
    """Configuration is missing required attributes to set policy."""
    pass


class CsrGenerationFailed(Exception):
    """CSR generation failed. An Error occured while generating a CSR."""
    pass


class CaDeniedConfiguration(Exception):
    """
    Ca cert is rejected due to Calvin security configuration
    or openssl.conf.
    """
    pass


class CaDeniedMalformed(Exception):
    """Ca cert is denied as it is malformed."""
    pass


class CertificateInvalid(Exception):
    """Certificate is not validly signed by CA."""
    pass


class CertificateDeniedMalformed(Exception):
    """Ca cert is denied as it is malformed."""
    pass


class CertificateDeniedConfiguration(Exception):
    """Certificate is denied due to restrictions in configuration."""
    pass


class CsrDeniedConfiguration(Exception):
    """A CSR is rejected due to Calvin security configuration."""
    pass


class CsrDeniedMalformed(Exception):
    """A CSR is denied as it is malformed."""
    pass


class StoreFailed(Exception):
    """Storing failed."""
    pass


class TransmissionFailed(Exception):
    """Failed to transmit."""
    pass


class ListenFailed(Exception):
    """Listening to interface failed."""
    pass


class ListenTimeout(Exception):
    """Listening timed out before receiving anything."""
    pass


class CaNotFound(Exception):
    """The CA cert file was not found."""
    pass


class Client(object):
    """
    A Client with state and methods to maintain the Client node
    procedures in a security discovery exchange.

    Node state diagram behaviour:
    digraph N {
        STATE.NEW -> STATE.CONFIGURED;
        STATE.CONFIGURED -> STATE.CSR_GENERATED;
        STATE.CONFIGURED -> STATE.CSR_GENERATE_FAILED;
        STATE.CSR_GENERATE_FAILED -> STATE.PANIC;
        STATE.CSR_GENERATED -> STATE.TRANSMIT;
        STATE.TRANSMIT -> STATE.CSR_REQUESTED;
        STATE.TRANSMIT -> STATE.TRANSMITTING_FAILED;
        STATE.TRANSMITTING_FAILED -> STATE.PANIC;
        STATE.CSR_REQUESTED -> STATE.LISTENING;
        STATE.LISTENING -> STATE.CERTIFICATE_RECEIVED;
        STATE.LISTENING -> STATE.LISTENING_TIMEOUT;
        STATE.LISTENING_TIMEOUT -> STATE.CSR_GENERATED;
        STATE.CERTIFICATE_RECEIVED -> STATE.CA_ACCEPTED_CONFIGURATION;
        STATE.CERTIFICATE_RECEIVED -> STATE.CA_DENIED_CONFIGURATION;
        STATE.CA_DENIED_CONFIGURATION -> STATE.LISTENING;
        STATE.CA_DENIED_MALFORMED -> STATE.LISTENING;
        STATE.CA_ACCEPTED_CONFIGURATION -> \
            STATE.CERTIFICATE_ACCEPTED_CONFIGURATION;
        STATE.CA_ACCEPTED_CONFIGURATION -> \
            STATE.CERTIFICATE_DENIED_CONFIGURATION;
        STATE.CERTIFICATE_DENIED_CONFIGURATION -> STATE.LISTENING;
        STATE.CERTIFICATE_ACCEPTED_CONFIGURATION -> STATE.CERTIFICATE_INVALID;
        STATE.CERTIFICATE_INVALID -> STATE.LISTENING;
        STATE.CERTIFICATE_ACCEPTED_CONFIGURATION -> STATE.CERTIFICATE_VALID;
        STATE.CERTIFICATE_VALID -> STATE.CA_STORED;
        STATE.CA_STORED -> STATE.STORE_FAILED;
        STATE.STORE_FAILED -> STATE.PANIC;
        STATE.CA_STORED -> STATE.CERTIFICATE_STORED;
        STATE.CERTIFICATE_STORED -> STATE.STORE_FAILED;
        STATE.CERTIFICATE_STORED -> STATE.SATISFIED;
        STATE.CERTIFICATE_STORED -> STATE.CSR_GENERATED;
    }
    """

    # TODO: Add a state and function to verify that the received certificate
    # is the one issued by this csr.

    def __init__(self, name):
        """Maintain state of a Node and store `configuration`."""
        self.state = STATE.NEW
        self.conf = calvinconfig.get()
        self.domain = ""
        self.name = name
        self.cert_conf = {}
        self.trusted_store = OpenSSL.crypto.X509Store()
        self.discover()

    def discover(self):
        """State machine that manages client current state."""
        try:
            if self.state == STATE.NEW:
                self.verify_configuration()

            if self.state == STATE.CONFIGURED:
                self.store_ca(self.cert_conf["CA_default"]["certificate"])

            if self.state == STATE.CA_STORED:
                csrfile = self.generate_csr()

            if self.state == STATE.CSR_GENERATED:
                self.csrdata = open(csrfile, 'r').read()
                self.transmit_csr(self.csrdata)

            if self.state == STATE.TRANSMIT:
                self.certdata = self.receive_cert()

            if self.state == STATE.CERTIFICATE_RECEIVED:
                self.validate_cert(self.certdata)

            if self.state == STATE.CERTIFICATE_VALID:
                self.store_certificate(self.certdata)
            # NOTE If we would want to support multiple CA's
            # this would be a good place to check if they were all configured.
            # self.state = self.check_configuration()
            #
            if self.state == STATE.SATISFIED:
                # This is were we check if all states have been achived.
                return self.state

        except (ConfigurationMalformed,
                CsrGenerationFailed,
                TransmissionFailed,
                ListenFailed,
                StoreFailed):
            # Fatal error, cause panic!
            raise
        except (CaDeniedConfiguration,
                CaDeniedMalformed,
                CertificateInvalid,
                CertificateDeniedMalformed,
                CertificateDeniedConfiguration):
            # Non fatal error, should cause retry STATE.CSR_GENERATED
            self.state = STATE.CSR_GENERATED
            self.discover()

    def verify_configuration(self):
        """
        Verify that the self.configuration contains required fields.
        Raise ConfigurationMalformed is any required field is missing.
        """
        try:
            self.conf.get_section("security")
            cert_conf_file = self.conf.get("security", "certificate_conf")
            self.domain = self.conf.get("security", "certificate_domain")
            self.cert_conf = certificate.Config(cert_conf_file,
                                                self.domain).configuration

            if self.cert_conf['CA_default']['certificate'] is None:
                raise ConfigurationMalformed("Missing `CA_default`."
                                             "`certificate` variable"
                                             " in {}".format(cert_conf_file))
        except (Exception), err:
            raise ConfigurationMalformed(err)
        self.state = STATE.CONFIGURED

    def generate_csr(self):
        """
        Generate CSR store csr on disk at `path`.
        Return path of new CSR.
        Rasie CsrGenerationFailed if csr generation fails.
        """
        config = certificate.Config(domain=self.domain)
        try:
            return certificate.new_runtime(config, self.name)
        except (IOError), err:
            raise CsrGenerationFailed(err)
        self.state = STATE.CSR_GENERATED

    def transmit_csr(self, csr):
        """
        Transmit `csr` certificate on multicast group
        using SSDP with a desired `cafp` as a certificate authority
        fingerprint.
        """
        raise NotImplementedError
        self.state = STATE.CSR_REQUESTED

    def receive_cert(self):
        """
        Listen for a signed certificate and a CA certificate response.
        Satisfy state STATE.CERTIFICATE_RECEIVED by receiving a certificates.
        Raise ListenFailed if listening failed.
        Return cert as string.
        """
        raise NotImplementedError
        raise ListenFailed
        self.state = STATE.CERTIFICATE_RECEIVED
        cert = ""
        return cert

    def validate_cert(self, cert):
        """
        Confirm that a `cert` is verifiably signed with CA from config.
        """
        try:
            verify_cert_with_policy(cert)
            load_certificate = OpenSSL.crypto.load_certificate
            certx509 = load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            store_ctx = OpenSSL.crypto.X509StoreContext(self.trusted_store,
                                                        certx509)
            store_ctx.verify_certificate()
        except (Exception), err:
            raise CertificateInvalid(err)

        self.state = STATE.CERTIFICATE_VALID

    def verify_certificate(self, cert):
        """
        Confirm that a certificate has a verifiable subject, expiry-time,
        signature strength, and domain belonging as defined by
        security configuration policy.
        raise CertificateInvalid if cert has expired.
        raise CertificateDeniedMalformed if cert cannot be parsed.
        raise CertificateDeniedConfiguration if cert is too weak or
        in the wrong domain.
        """
        load_certificate = OpenSSL.crypto.load_certificate
        certx509 = load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
        # issuer = certx509.get_issuer()
        # TODO: Check that issuer is CA.
        subject = certx509.get_subject()
        serial = certx509.get_serial_number()
        if certx509.has_expired():
            raise CertificateInvalid("Certificate has expired.")
        if serial < 0:
            raise CertificateDeniedMalformed("Serial number was negative.")
        try:
            verify_cert_with_policy(cert)
            certx509.get_signature_algorithm()  # TODO: Check sig alg strength
        except ValueError:
            raise CertificateDeniedMalformed("Unknown signature algorithm.")
        if subject.organization is not self.domain:
            raise CertificateDeniedConfiguration("Certificate organization"
                                                 " is not domain.")
        self.state = STATE.CERTIFICATE_ACCEPTED_POLICY

    def store_ca(self, cacert_file):
        """
        Store `cacert_file` in self.trusted_store.
        """
        try:
            cax509 = load_cert(cacert_file)
            self.trusted_store.add_cert(cax509)
        except (Exception), err:
            raise StoreFailed(err)
        self.state = STATE.CA_STORED

    def store_certificate(self, cert):
        """
        Store a `cert` in path defined by configuration.
        raise StoreFailed if storing failed.
        raise IOError if path is not found.
        raise OSError if permissions are insuficcient.
        """
        runtimes = self.conf["CA_default"]["runtimes_dir"]
        load_certificate = OpenSSL.crypto.load_certificate
        try:
            certx509 = load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            subject = certx509.get_subject()
            digest = certx509.digest("sha256")
            filename = "{}.pem".format(digest)
            filepath = os.path.join(runtimes,
                                    subject.commonName,
                                    "mine",
                                    filename)
            with open(filepath, 'w') as cert_fd:
                cert_fd.write(cert)
        except (Exception), err:
            raise StoreFailed(err)
        self.state = STATE.CERTIFICATE_STORED
        return filepath

    def satisfied(self):
        """
        Check Node security configuration requirements and
        verify that this Node object is satisfied with its current state.
        Return True and set self.state = STATE.SATISFIED if satisfactory
        requirements are met otherwise return False and set state to desired
        next action.
        """
        if self.state == STATE.CERTIFICATE_VALID:
            # This is where we check is all states have been reached.
            self.state = STATE.SATISFIED


class Ca(object):
    """
    Certificate Authority class.

    Certificate Authority state diagram behaviour:
    digraph C {
        STATE.NEW -> STATE.CONFIGURED;
        STATE.NEW -> STATE.CONFIGURAION_FAILED;
        STATE.CONFIGURAION_FAILED -> STATE.PANIC;
        STATE.CONFIGURED -> STATE.CA_GENERATED;
        STATE.CA_GENERATED -> STATE.LISTENING;
        STATE.LISTENING -> STATE.CSR_RECEIVED;
        STATE.CSR_RECEIVED -> STATE.CSR_ACCEPTED;
        STATE.CSR_RECEIVED -> STATE.CSR_ALREDY_SIGNED;
        STATE.CSR_ALREDY_SIGNED -> STATE.TRANSMIT;
        STATE.CSR_RECEIVED -> STATE.CSR_DENIED_CONFIGURATION;
        STATE.CSR_RECEIVED -> STATE.CSR_DENIED_MALLFORMED;
        STATE.CSR_ACCEPTED -> STATE.CSR_STORED;
        STATE.CSR_ACCEPTED -> STATE.STORE_FAILED;
        STATE.CSR_STORED -> STATE.CERTIFICATE_GENERATED;
        STATE.CERTIFICATE_GENERATED -> STATE.STORE_FAILED;
        STATE.LISTENING -> STATE.LISTEN_FAILED;
        STATE.LISTEN_FAILED -> STATE.PANIC;
        STATE.STORE_FAILED -> STATE.PANIC;
        STATE.CERTIFICATE_GENERATED -> STATE.TRANSMIT;
        STATE.TRANSMIT -> STATE.TRANSMISSION_FAILED;
        STATE.TRANSMISSION_FAILED -> STATE.TRANSMIT;
        STATE.TRANSMIT -> STATE.CA_GENERATED;
    }
    """

    def __init__(self):
        """Hold Ca state."""
        self.state = STATE.NEW
        self.conf = calvinconfig.get()
        self.domain = ""
        self.cafile = ""
        self.csrdata = ""
        self.csrfile = ""
        self.certfile = ""
        self.cert_conf = {}

    def discover(self):
        """
        CA service state traverser.
        Note.
        Runnign multiple instances of CA may cause problems
        as signing CSR's require serial numbers to be generated
        in serial (hence the name).
        """
        try:
            if self.state == STATE.NEW:
                self.verify_configuration()

            if self.state == STATE.CONFIGURED:
                self.cafile = self.find_ca()

            if self.state == STATE.LISTENING:
                self.csrdata = self.receive_csr()

            if self.state == STATE.CSR_RECEIVED:
                self.validate_csr(self.csrdata)

            if self.state == STATE.CSR_ACCEPTED:
                self.csrfile = self.store_csr(self.csrdata)

            if self.state == STATE.STORED:
                self.certfile = self.sign_csr(self.csrfile)

            if self.state == STATE.CERTIFICATE_GENERATED:
                self.transmit_cert(self.certfile)

            if self.state == STATE.TRANSMIT:
                self.state = STATE.CA_GENERATED
                self.discover()

        except CaNotFound:
            certificate.new_domain(self.domain)
            self.state = STATE.CONFIGURED
            self.discover()
            return

    def verify_configuration(self):
        """
        Verify that the self.conf and openssl.conf contains required fields.
        """
        try:
            self.conf.get_section("security")
            cert_conf_file = self.conf.get("security", "certificate_conf")
            self.domain = self.conf.get("security", "certificate_domain")
            self.cert_conf = certificate.Config(cert_conf_file,
                                                self.domain).configuration

            if self.cert_conf['CA_default']['certificate'] is None:
                raise ConfigurationMalformed("Missing `CA_default`."
                                             "`certificate` variable"
                                             " in {}".format(cert_conf_file))
        except (Exception), err:
            raise ConfigurationMalformed(err)
        self.state = STATE.CONFIGURED

    def find_ca(self):
        """
        Raise CaNotFound if a certificate authority cert is missing.
        Raise CaDeniedMalmformed if the configured CA is malformed.
        """
        try:
            load_cert(self.cert_conf['CA_default']['certificate'])
        except IOError:
            raise CaNotFound("Ca file not found,")
        except (OpenSSL.crypto.Error), err:
            raise CaDeniedMalformed(err)

    def receive_csr(self):
        """
        Listen for `csr` certificate on multicast group
        using SSDP.
        Return csrdata, cadata.
        raise ListenFailed if binding to ssdp fails.
        """
        csrdata = ""
        raise ListenFailed
        self.state = STATE.CSR_RECEIVED
        return csrdata

    def store_csr(self, csr):
        """
        Store `csr` in newcerts location from configuration.
        Raise store failed if there was problems storing.
        Return path to csr-file.
        """
        new_cert = self.conf["CA_default"]["new_certs_dir"]
        load_csr = OpenSSL.crypto.load_certificate_request
        try:
            csrx509 = load_csr(OpenSSL.crypto.FILETYPE_PEM, csr)
            subject = csrx509.get_subject()
            filename = "{}.csr".format(subject.commonName)
            filepath = os.path.join(new_cert, filename)
            with open(filepath, 'w') as csr_fd:
                csr_fd.write(csr)
        except (Exception), err:
            raise StoreFailed(err)
        return filepath

    def validate_csr(self, csr):
        """
        Validate that the `csr` matches with configuration.
        Raise CsrDeniedConfiguration if the CSR did not satisfy the
        configuration.
        Raise CsrDeniedMalformed if the csr could not be read at all.
        Raise CertDeniedConfiguration is the CSR key is too short.
        """
        verify_cert_with_policy(csr)
        try:
            load_csr = OpenSSL.crypto.load_certificate_request
            csrx509 = load_csr(OpenSSL.crypto.FILETYPE_PEM, csr)
        except (OpenSSL.crypto.Error, IOError), err:
            raise CsrDeniedMalformed(err)
        try:
            subject = csrx509.get_subject()
            common_name = subject.commonName
            organization = subject.organization
            # TODO: Check subject items against conf!
            # TODO: Make sure there is a configuration entry for CA services
            # to filter accepted nodes.
            # The openssl policy can also do this ...
        except (OpenSSL.crypto.Error), err:
            raise CsrDeniedConfiguration(err)
        self.state = STATE.CSR_ACCEPTED

    def sign_csr(self, csrfile):
        """
        Sign the `csrfile`, return certificate file path.
        Raise StoreFailed if there was a problem storing the certificate.
        """
        try:
            config = certificate.Config(domain=self.domain)
            cert = load_cert(csrfile)
            subject_hash = cert.subject_name_hash()
            certfile = certificate.sign_req(config, csrfile, subject_hash)
        except (IOError), err:
            raise StoreFailed(err)
        return certfile

    def transmit_cert(self, cert):
        """
        Transmit `cert` certificate, and certificate authority
        to a multicast group using SSDP.
        """
        raise NotImplementedError
        raise TransmissionFailed
        self.state = STATE.TRANSMIT
