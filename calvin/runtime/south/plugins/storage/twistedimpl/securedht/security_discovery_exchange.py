"""
Security Discovery Exchange.
The purpose of this module is to create an exchange of credentials
from a new Client joining a domain to a Certificate Authority
authorizing the new Node to join the domain.

Transmit a Certificate Signature Request from a new node over multicast SSDP
to a Certificate Authority Cettificate Authority can sign request or not
depending on a configuration over unicast.
Node         Certificate Authority
 |------CSR,CA-FP---->|
 |                    | Signature()
 |<---Certificate,CA--|
 |                    |

The certificate discovery services are divided in two sections.
One for new clients and one for certificate authority functions.
By collecting and recording states for a Node and a Ca it is possible to
leave a Security Discovery Exchange at any time and continue later if a
temporary error has occured.
Errors generate exceptions and the exception handler manages the error state
unless successfull.

Use sphinx.ext.autodoc to extract comments on enums.
"""

import os

import OpenSSL

from calvin.utilities.utils import enum
from calvin.utilities import certificate
from calvin.utilities import calvinconfig
from calvin.utilities import calvinlogger

_log = calvinlogger.get_logger(__name__)


STATE = enum("NEW",  # Object is initiated but not loaded or started.
             "CONFIGURED",  # An acceptable configuration is loaded.
             "LISTENING",  # Listen for request or response.
             "TRANSMIT",  # Transmit a request or response.
             "SATISFIED",  # Required security discoveries established.
             "CSR_GENERATED",  # CSR has been generated.
             "CSR_REQUESTED",  # CSR has been requested.
             "CERTIFICATE_RECEIVED",  # Certificate has been received.
             "CERTIFICATE_VALID",  # Certificate validly signed by CA.
             "CA_ACCEPTED_CONFIGURATION",  # CAcert meets config requirements.
             "CERTIFICATE_ACCEPTED_CONFIGURATION",  # Certificate meets req.
             "CA_STORED",  # CA cert stored.
             "CERTIFICATE_STORED",  # Certificate stored.
             "CA_GENERATED",  # CA cert generated.
             "CSR_RECEIVED",  # CSR has been received.
             "CSR_ACCEPTED",  # CSR meets config requirements.
             "CSR_STORED",  # CSR stored in new csr location
             "CSR_SIGNED",  # CSR have been signed by CA.
             "CSR_ALREDY_SIGNED",  # The requested CSR already signed.
             "CERTIFICATE_GENERATED")  # Certificate generated by CA

TYPE_ECC = 408  # Internal type name for ECC keys in version3 of PKCS#10.


# Generic helper functions.
def load_cert(cert_file):
    """
    Load the `cert_file` (can be CSR or CERT) to a
    OpenSSL X509 object and return it.

    Raise IOError if the file is missing.
    Raise OpenSSL.crypto.Error on OpenSSL errors.
    """
    with open(cert_file, 'r') as ca_fd:
        cadata = ca_fd.read()
    return load_certdata(cadata)

def load_certdata(cadata):
    """
    Load the `cert_file` (can be CSR or CERT) to a
    OpenSSL X509 object and return it.

    Raise IOError if the file is missing.
    Raise OpenSSL.crypto.Error on OpenSSL errors.
    """
    if certificate.BEGIN_LINE in cadata:
        cert_part = cadata.split(certificate.BEGIN_LINE)[1]
        certstr = "{}{}".format(certificate.BEGIN_LINE, cert_part)
        load_certificate = OpenSSL.crypto.load_certificate
        try:
            cert = load_certificate(OpenSSL.crypto.FILETYPE_PEM, certstr)
        except:
            raise
    elif certificate.BEGIN_CSR_LINE in cadata:
        cert_part = cadata.split(certificate.BEGIN_CSR_LINE)[1]
        certstr = "{}{}".format(certificate.BEGIN_CSR_LINE, cert_part)
        load_certificate = OpenSSL.crypto.load_certificate_request
        try:
            cert = load_certificate(OpenSSL.crypto.FILETYPE_PEM, certstr)
        except:
            raise
    else:
        raise CertificateMalformed()
    return cert

def verify_cert_with_policy(cert):
    """
    Confirm that a `cacert` is allowed in security configuration policy.
    Comparing with NIST:
    http://csrc.nist.gov/publications/PubsFIPS.html#fips186-3
    """
    certx509 = load_cert(cert)
    verify_certdata_with_policy(certx509)

def verify_certstr_with_policy(cert):
    """
    Confirm that a `cacert` is allowed in security configuration policy.
    Comparing with NIST:
    http://csrc.nist.gov/publications/PubsFIPS.html#fips186-3
    """
    certx509 = load_certdata(cert)
    verify_certdata_with_policy(certx509)
    return certx509

def verify_certdata_with_policy(certx509):
    pubkey = certx509.get_pubkey()
    if pubkey.type() is TYPE_ECC and pubkey.bits() < 256:
        raise CertificateDeniedConfiguration("Too small ECC key in cert.")
    if pubkey.type() is OpenSSL.crypto.TYPE_RSA and pubkey.bits < 2048:
        raise CertificateDeniedConfiguration("Too small RSA key in cert.")
    if pubkey.type() is OpenSSL.crypto.TYPE_DSA and pubkey.bits < 2048:
        raise CertificateDeniedConfiguration("Too small DSA key in cert.")


# Exceptions
class ConfigurationMalformed(Exception):
    """Configuration is missing required attributes to set policy."""
    pass


class CsrGenerationFailed(Exception):
    """CSR generation failed. An Error occured while generating a CSR."""
    pass


class CaDeniedConfiguration(Exception):
    """
    Ca cert is rejected due to Calvin security configuration
    or openssl.conf.
    """
    pass


class CaDeniedMalformed(Exception):
    """Ca cert is denied as it is malformed."""
    pass


class CertificateInvalid(Exception):
    """Certificate is not validly signed by CA."""
    pass


class CertificateMalformed(Exception):
    """Certificate is not validly signed by CA."""
    pass


class CertificateDeniedMalformed(Exception):
    """Ca cert is denied as it is malformed."""
    pass


class CertificateDeniedConfiguration(Exception):
    """Certificate is denied due to restrictions in configuration."""
    pass


class CsrDeniedConfiguration(Exception):
    """A CSR is rejected due to Calvin security configuration."""
    pass


class CsrDeniedMalformed(Exception):
    """A CSR is denied as it is malformed."""
    pass


class StoreFailed(Exception):
    """Storing failed."""
    pass


class TransmissionFailed(Exception):
    """Failed to transmit."""
    pass


class ListenFailed(Exception):
    """Listening to interface failed."""
    pass


class ListenTimeout(Exception):
    """Listening timed out before receiving anything."""
    pass


class CaNotFound(Exception):
    """The CA cert file was not found."""
    pass


class Client(object):
    """
    A Client with state and methods to maintain the Client node
    procedures in a security discovery exchange.

    Node state diagram behaviour:
    digraph N {
        STATE.NEW -> STATE.CONFIGURED;
        STATE.CONFIGURED -> STATE.CSR_GENERATED;
        STATE.CONFIGURED -> STATE.CSR_GENERATE_FAILED;
        STATE.CSR_GENERATE_FAILED -> STATE.PANIC;
        STATE.CSR_GENERATED -> STATE.TRANSMIT;
        STATE.TRANSMIT -> STATE.CSR_REQUESTED;
        STATE.TRANSMIT -> STATE.TRANSMITTING_FAILED;
        STATE.TRANSMITTING_FAILED -> STATE.PANIC;
        STATE.CSR_REQUESTED -> STATE.LISTENING;
        STATE.LISTENING -> STATE.CERTIFICATE_RECEIVED;
        STATE.LISTENING -> STATE.LISTENING_TIMEOUT;
        STATE.LISTENING_TIMEOUT -> STATE.CSR_GENERATED;
        STATE.CERTIFICATE_RECEIVED -> STATE.CA_ACCEPTED_CONFIGURATION;
        STATE.CERTIFICATE_RECEIVED -> STATE.CA_DENIED_CONFIGURATION;
        STATE.CA_DENIED_CONFIGURATION -> STATE.LISTENING;
        STATE.CA_DENIED_MALFORMED -> STATE.LISTENING;
        STATE.CA_ACCEPTED_CONFIGURATION -> \
            STATE.CERTIFICATE_ACCEPTED_CONFIGURATION;
        STATE.CA_ACCEPTED_CONFIGURATION -> \
            STATE.CERTIFICATE_DENIED_CONFIGURATION;
        STATE.CERTIFICATE_DENIED_CONFIGURATION -> STATE.LISTENING;
        STATE.CERTIFICATE_ACCEPTED_CONFIGURATION -> STATE.CERTIFICATE_INVALID;
        STATE.CERTIFICATE_INVALID -> STATE.LISTENING;
        STATE.CERTIFICATE_ACCEPTED_CONFIGURATION -> STATE.CERTIFICATE_VALID;
        STATE.CERTIFICATE_VALID -> STATE.CA_STORED;
        STATE.CA_STORED -> STATE.STORE_FAILED;
        STATE.STORE_FAILED -> STATE.PANIC;
        STATE.CA_STORED -> STATE.CERTIFICATE_STORED;
        STATE.CERTIFICATE_STORED -> STATE.STORE_FAILED;
        STATE.CERTIFICATE_STORED -> STATE.SATISFIED;
        STATE.CERTIFICATE_STORED -> STATE.CSR_GENERATED;
    }
    """

    # TODO: Add a state and function to verify that the received certificate
    # is the one issued by this csr.

    def __init__(self, name, nodeid, search, certificate_stored):
        """ Maintain state of a Node and store `configuration`.
            name is the runtime name,
            nodeid is the runtime's id,
            search is a function taking csr as kw arg to search for signing CA
            certificate_stored is a function that is called when the sign certificate is stored
        """
        self.state = STATE.NEW
        self.conf = calvinconfig.get()
        self.domain = ""
        self.nodeid = nodeid
        self.name = name
        self.search = search
        self.certificate_stored = certificate_stored
        self.cert_conf = {}
        self.trusted_store = OpenSSL.crypto.X509Store()
        self.discover()

    def discover(self):
        """State machine that manages client current state."""
        try:
            if self.state == STATE.NEW:
                self.verify_configuration()

            if self.state == STATE.CONFIGURED:
                self.store_ca(self.cert_conf["CA_default"]["certificate"])

            if self.state == STATE.CA_STORED:
                self.csrfile = self.generate_csr()

            if self.state == STATE.CSR_GENERATED:
                self.csrdata = open(self.csrfile, 'r').read()
                self.transmit_csr(self.csrdata)

            if self.state == STATE.CSR_REQUESTED:
                # Just return and wait for response to trigger again
                return

            if self.state == STATE.CERTIFICATE_RECEIVED:
                self.validate_cert(self.certdata)

            if self.state == STATE.CERTIFICATE_VALID:
                self.store_certificate(self.certdata)
            # NOTE If we would want to support multiple CA's
            # this would be a good place to check if they were all configured.
            # self.state = self.check_configuration()
            #
            if self.state == STATE.CERTIFICATE_STORED:
                self.satisfied()

            if self.state == STATE.SATISFIED:
                return

        except (ConfigurationMalformed,
                CsrGenerationFailed,
                TransmissionFailed,
                ListenFailed,
                StoreFailed):
            # Fatal error, cause panic!
            _log.error("client.fatal_error")
            raise
        except (CaDeniedConfiguration,
                CaDeniedMalformed,
                CertificateInvalid,
                CertificateDeniedMalformed,
                CertificateDeniedConfiguration):
            # Non fatal error, should cause retry STATE.CSR_GENERATED
            _log.warning("client.non_fatal_error")
            self.state = STATE.CSR_GENERATED
            self.discover()

    def verify_configuration(self):
        """
        Verify that the self.configuration contains required fields.
        Raise ConfigurationMalformed is any required field is missing.
        """
        _log.debug("client.verify_configuration")
        try:
            cert_conf_file = self.conf.get("security", "certificate_conf")
            self.domain = self.conf.get("security", "certificate_domain")
            self.cert_conf_obj = certificate.Config(cert_conf_file,
                                                self.domain)
            self.cert_conf = self.cert_conf_obj.configuration

            if self.cert_conf['CA_default']['certificate'] is None:
                raise ConfigurationMalformed("Missing `CA_default`."
                                             "`certificate` variable"
                                             " in {}".format(cert_conf_file))
        except (Exception), err:
            raise ConfigurationMalformed(err)
        self.state = STATE.CONFIGURED

    def generate_csr(self):
        """
        Generate CSR store csr on disk at `path`.
        Return path of new CSR.
        Rasie CsrGenerationFailed if csr generation fails.
        """
        _log.debug("client.generate_csr")
        try:
            csrfile = certificate.new_runtime(self.cert_conf_obj, self.name, nodeid=self.nodeid)
            self.state = STATE.CSR_GENERATED
            return csrfile
        except (IOError), err:
            raise CsrGenerationFailed(err)

    def transmit_csr(self, csr):
        """
        Transmit `csr` certificate on multicast group
        using SSDP with a desired `cafp` as a certificate authority
        fingerprint.
        """
        _log.debug("client.transmit_csr")
        self.search(csr=csr)
        self.state = STATE.CSR_REQUESTED

    def receive_cert_callback(self, certdata):
        """
        Callback for a signed certificate and a CA certificate response.
        Satisfy state STATE.CERTIFICATE_RECEIVED by receiving a certificates.
        Save certdata and continue discover process
        """
        _log.debug("client.receive_cert_callback")
        self.certdata = certdata
        self.state = STATE.CERTIFICATE_RECEIVED
        self.discover()

    # Not used
    def receive_cert(self):
        """
        Listen for a signed certificate and a CA certificate response.
        Satisfy state STATE.CERTIFICATE_RECEIVED by receiving a certificates.
        Raise ListenFailed if listening failed.
        Return cert as string.
        """
        _log.debug("client.receive_cert")
        #raise ListenFailed
        self.state = STATE.CERTIFICATE_RECEIVED
        cert = ""
        return cert

    def validate_cert(self, cert):
        """
        Confirm that a `cert` is verifiably signed with CA from config.
        """
        _log.debug("client.validate_cert")
        try:
            certx509 = verify_certstr_with_policy(cert)
            store_ctx = OpenSSL.crypto.X509StoreContext(self.trusted_store,
                                                        certx509)
            store_ctx.verify_certificate()
        except (Exception), err:
            raise CertificateInvalid(err)

        self.state = STATE.CERTIFICATE_VALID

    # Not used
    def verify_certificate(self, cert):
        """
        Confirm that a certificate has a verifiable subject, expiry-time,
        signature strength, and domain belonging as defined by
        security configuration policy.
        raise CertificateInvalid if cert has expired.
        raise CertificateDeniedMalformed if cert cannot be parsed.
        raise CertificateDeniedConfiguration if cert is too weak or
        in the wrong domain.
        """
        _log.debug("client.verify_certificate")
        load_certificate = OpenSSL.crypto.load_certificate
        certx509 = load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
        # issuer = certx509.get_issuer()
        # TODO: Check that issuer is CA.
        subject = certx509.get_subject()
        serial = certx509.get_serial_number()
        if certx509.has_expired():
            raise CertificateInvalid("Certificate has expired.")
        if serial < 0:
            raise CertificateDeniedMalformed("Serial number was negative.")
        try:
            verify_cert_with_policy(cert)
            certx509.get_signature_algorithm()  # TODO: Check sig alg strength
        except ValueError:
            raise CertificateDeniedMalformed("Unknown signature algorithm.")
        if subject.organization is not self.domain:
            raise CertificateDeniedConfiguration("Certificate organization"
                                                 " is not domain.")
        self.state = STATE.CERTIFICATE_ACCEPTED_POLICY

    def store_ca(self, cacert_file):
        """
        Store `cacert_file` in self.trusted_store.
        """
        _log.debug("client.store_ca")
        try:
            cax509 = load_cert(cacert_file)
            self.trusted_store.add_cert(cax509)
        except (Exception), err:
            raise StoreFailed(err)
        self.state = STATE.CA_STORED

    def store_certificate(self, cert):
        """
        Store a `cert` in path defined by configuration.
        raise StoreFailed if storing failed.
        raise IOError if path is not found.
        raise OSError if permissions are insuficcient.
        """
        _log.debug("client.store_certificate")
        runtimes = self.cert_conf["CA_default"]["runtimes_dir"]
        try:
            certx509 = load_certdata(cert)
            subject = certx509.get_subject()
            fingerprint = certx509.digest("sha256")
            id = fingerprint.replace(":", "")[-40:]
            filename = "{}.pem".format(id)
            filepath = os.path.join(runtimes,
                                    subject.commonName,
                                    "mine",
                                    filename)
            _log.debug("Store signed cert as %s" % filepath)
            os.makedirs(os.path.dirname(filepath))
            with open(filepath, 'w') as cert_fd:
                cert_fd.write(cert)
        except (Exception), err:
            _log.exception("Storing signed cert failed")
            raise StoreFailed(err)
        self.state = STATE.CERTIFICATE_STORED
        return filepath

    def satisfied(self):
        """
        Check Node security configuration requirements and
        verify that this Node object is satisfied with its current state.
        Return True and set self.state = STATE.SATISFIED if satisfactory
        requirements are met otherwise return False and set state to desired
        next action.
        """
        _log.debug("client.satisfied")
        if self.state == STATE.CERTIFICATE_STORED:
            # This is where we check is all states have been reached.
            self.state = STATE.SATISFIED


class Ca(object):
    """
    Certificate Authority class.

    Certificate Authority state diagram behaviour:
    digraph C {
        STATE.NEW -> STATE.CONFIGURED;
        STATE.NEW -> STATE.CONFIGURAION_FAILED;
        STATE.CONFIGURAION_FAILED -> STATE.PANIC;
        STATE.CONFIGURED -> STATE.CA_GENERATED;
        STATE.CA_GENERATED -> STATE.LISTENING;
        STATE.LISTENING -> STATE.CSR_RECEIVED;
        STATE.CSR_RECEIVED -> STATE.CSR_ACCEPTED;
        STATE.CSR_RECEIVED -> STATE.CSR_ALREDY_SIGNED;
        STATE.CSR_ALREDY_SIGNED -> STATE.TRANSMIT;
        STATE.CSR_RECEIVED -> STATE.CSR_DENIED_CONFIGURATION;
        STATE.CSR_RECEIVED -> STATE.CSR_DENIED_MALLFORMED;
        STATE.CSR_ACCEPTED -> STATE.CSR_STORED;
        STATE.CSR_ACCEPTED -> STATE.STORE_FAILED;
        STATE.CSR_STORED -> STATE.CERTIFICATE_GENERATED;
        STATE.CERTIFICATE_GENERATED -> STATE.STORE_FAILED;
        STATE.LISTENING -> STATE.LISTEN_FAILED;
        STATE.LISTEN_FAILED -> STATE.PANIC;
        STATE.STORE_FAILED -> STATE.PANIC;
        STATE.CERTIFICATE_GENERATED -> STATE.TRANSMIT;
        STATE.TRANSMIT -> STATE.TRANSMISSION_FAILED;
        STATE.TRANSMISSION_FAILED -> STATE.TRANSMIT;
        STATE.TRANSMIT -> STATE.CA_GENERATED;
    }
    """

    def __init__(self, name, csrdata=None):
        """Hold Ca state."""
        self.name = name
        self.state = STATE.NEW
        self.conf = calvinconfig.get()
        self.domain = ""
        self.cafile = ""
        self.csrdata = "" if csrdata is None else csrdata
        self.csrfile = ""
        self.certfile = ""
        self.cert_conf = {}
        self.signed_cert = None
        if csrdata:
            self.discover()

    def discover(self):
        """
        CA service state traverser.
        Note.
        Runnign multiple instances of CA may cause problems
        as signing CSR's require serial numbers to be generated
        in serial (hence the name).
        """
        try:
            if self.state == STATE.NEW:
                self.verify_configuration()

            if self.state == STATE.CONFIGURED:
                self.cafile = self.find_ca()

            if self.state == STATE.LISTENING:
                self.receive_csr()

            if self.state == STATE.CSR_RECEIVED:
                self.validate_csr(self.csrdata)

            if self.state == STATE.CSR_ACCEPTED:
                self.csrfile = self.store_csr(self.csrdata)

            if self.state == STATE.CSR_STORED:
                self.certfile = self.sign_csr(self.csrfile)

            if self.state == STATE.CERTIFICATE_GENERATED:
                self.signed_cert = self.transmit_cert(self.certfile)

        except CaNotFound:
            certificate.new_domain(self.domain)
            self.state = STATE.CONFIGURED
            self.discover()
            _log.error("ca.fatal_error")
            return

    def verify_configuration(self):
        """
        Verify that the self.conf and openssl.conf contains required fields.
        """
        _log.debug("ca.verify_configuration")
        try:
            cert_conf_file = self.conf.get("security", "certificate_conf")
            self.domain = self.conf.get("security", "certificate_domain")
            self.cert_conf_obj = certificate.Config(cert_conf_file,
                                                self.domain)
            self.cert_conf = self.cert_conf_obj.configuration

            if self.cert_conf['CA_default']['certificate'] is None:
                raise ConfigurationMalformed("Missing `CA_default`."
                                             "`certificate` variable"
                                             " in {}".format(cert_conf_file))
            if self.cert_conf['CA_default']['private_key'] is None:
                raise ConfigurationMalformed("Missing `CA_default`."
                                             "`private_key` variable"
                                             " in {}".format(cert_conf_file))
        except (Exception), err:
            raise ConfigurationMalformed(err)
        self.state = STATE.CONFIGURED

    def find_ca(self):
        """
        Raise CaNotFound if a certificate authority cert is missing.
        Raise CaDeniedMalmformed if the configured CA is malformed.
        Also check that the private key is available
        """
        _log.debug("ca.find_ca")
        try:
            load_cert(self.cert_conf['CA_default']['certificate'])
        except IOError:
            raise CaNotFound("Ca file not found,")
        except (OpenSSL.crypto.Error), err:
            raise CaDeniedMalformed(err)
        if not os.path.isfile(self.cert_conf['CA_default']['private_key']):
            raise CaNotFound("Ca private key file not found,")
        self.state = STATE.LISTENING

    def receive_csr(self):
        """
        Listen for `csr` certificate on multicast group
        using SSDP.
        Return csrdata, cadata.
        raise ListenFailed if binding to ssdp fails.
        """
        _log.debug("ca.receive_csr")
        if self.csrdata is None:
            raise ListenFailed
        self.state = STATE.CSR_RECEIVED

    def store_csr(self, csr):
        """
        Store `csr` in newcerts location from configuration.
        Raise store failed if there was problems storing.
        Return path to csr-file.
        """
        _log.debug("ca.store_csr")
        new_cert = self.cert_conf["CA_default"]["new_certs_dir"]
        load_csr = OpenSSL.crypto.load_certificate_request
        try:
            csrx509 = load_csr(OpenSSL.crypto.FILETYPE_PEM, csr)
            subject = csrx509.get_subject()
            filename = "{}.csr".format(subject.commonName)
            filepath = os.path.join(new_cert, filename)
            with open(filepath, 'w') as csr_fd:
                csr_fd.write(csr)
        except (Exception), err:
            raise StoreFailed(err)
        self.state = STATE.CSR_STORED
        return filepath

    def validate_csr(self, csr):
        """
        Validate that the `csr` matches with configuration.
        Raise CsrDeniedConfiguration if the CSR did not satisfy the
        configuration.
        Raise CsrDeniedMalformed if the csr could not be read at all.
        Raise CertDeniedConfiguration is the CSR key is too short.
        """
        _log.debug("ca.validate_csr %s" % csr)
        try:
            csrx509 = verify_certstr_with_policy(csr)
        except (OpenSSL.crypto.Error, IOError), err:
            raise CsrDeniedMalformed(err)
        except:
            raise
        try:
            subject = csrx509.get_subject()
            common_name = subject.commonName
            domain = subject.organizationName
            try:
                dnQualifier = subject.dnQualifier
            except:
                dnQualifier = "missing"
            _log.debug("CSR name: %s org: %s qualifier: %s" % (common_name, domain, dnQualifier))
            if self.domain != domain:
                raise CsrDeniedConfiguration("Wrong domain")
            # TODO: Check more subject items against conf!
            # TODO: Make sure there is a configuration entry for CA services
            # to filter accepted nodes, e.g. implement node name whitelist.
            # The openssl policy can also do this ...
        except (OpenSSL.crypto.Error), err:
            raise CsrDeniedConfiguration(err)
        self.state = STATE.CSR_ACCEPTED

    def sign_csr(self, csrfile):
        """
        Sign the `csrfile`, return certificate file path.
        Raise StoreFailed if there was a problem storing the certificate.
        """
        _log.debug("ca.sign_csr")
        try:
            cert = load_cert(csrfile)
            certfile = certificate.sign_req(self.cert_conf_obj, csrfile, self.name, other=True)
        except (IOError), err:
            raise StoreFailed(err)
        self.state = STATE.CERTIFICATE_GENERATED
        return certfile

    def transmit_cert(self, cert_file):
        """
        Transmit `cert_file` certificate, and certificate authority
        to a multicast group using SSDP by returning.
        """
        _log.debug("ca.transmit_cert")
        try:
            with open(cert_file, 'r') as ca_fd:
                cert_data = ca_fd.read()
        except (IOError), err:
            raise ListenFailed()
        self.state = STATE.TRANSMIT
        return cert_data